from mango_disease_app.models import *
from datetime import date
from scipy.special import comb
import calendar

# CREDIT: All docstrings in this file have been generated by ChatGPT

### ------ THE IDEA BEHIND THIS PLANNER ALGORITHM -------
# This planner defines numerous factors that interplay when deciding how often an orchard needs to be checked
# While the weightings have only been loosely chosen based on heuristics, it is very easy to redefine them based on expert advice.

def generate_plan(user):
    """    
    Generates a disease monitoring plan for all orchards owned by the given user.

    Overview:
    ---------
    This function calculates a risk score for each orchard based on:
    - Active disease cases (if any)
    - Latest general inspection records
    - Environmental and agronomic risk factors

    Decision Logic:
    ---------------
    - If there are active Cases for an orchard:
        - The risk is calculated using disease severity, spreadability.
        - The function uses worst-case values across all active Cases.
    - If no active Cases are present:
        - The risk is calculated only from environmental factors (stocking rate, season)
          and recent general inspection history

    Regardless of Cases, all orchards consider:
    - Variety susceptability (variety score)
    - Location susceptability (location score)
    - Tree density (stocking score)
    - Time since last inspection (last check score)
    - Inspection sensitivity (portion of trees checked)
    - Seasonal disease/pest risk based on location hemisphere and time of year

    Parameters:
    -----------
    user : User
        The authenticated user whose orchards will be evaluated.

    Risk Factors (Normalized 0-1 scale):
    ------------------------------------
    - severity : float
        Max severity across active Cases' diseases.
    - spreadability : float
        Max spreadability across active Cases' diseases.
    - variety_score : float
        Variety's susceptibility score.
    - location_score : float
        Location's susceptibility score.
    - stocking_score : float
        Orchard tree density normalized against max density.
    - last_check_score : float
        Normalized days since the orchard's last inspection record.
    - season_score : float
        Season-based environmental risk factor.
    - sensitivity : float
        Portion of the orchard inspected in the most recent record (higher coverage = lower risk).

    Returns:
    --------
    list of dict
        Each dict contains:
        - 'orchard' : Orchard name
        - 'risk_score' : Total weighted risk score (rounded to 2 decimals)
        - 'data_used' : Dictionary summarizing key factors used in the calculation.

    Notes:
    ------
    - Records can be linked to active Cases (for ongoing disease management)
      or can be standalone (general monitoring).
    - When no Cases are active, the function relies on environmental risk and inspection history.
    - The weightings of each factor can be fine-tuned based on expert agronomic advice.
    - Higher risk scores indicate orchards needing more frequent inspection.
    """
        
    # ----- REDEFINE WEIGHTINGS HERE BASED ON EXPERT EVIDENCE (should add to 1) ------
    weightings = {
        'severity': 0.15,
        'spreadability': 0.15,
        'variety_score': 0.025,
        'location_score': 0.025,
        'stocking_score': 0.2,
        'last_check_score': 0.05,
        'season_score': 0.25,
        'sensitivity_score': 0.15,
    }
    
    orchards = Orchard.objects.filter(user=user)
    plan = []
    data_used = {}
    
    for orchard in orchards:
        # records that are active and associated with the orchard
        active_cases = Case.objects.filter(orchard=orchard, status__iexact='active')
                
        if active_cases.exists(): # diseases have been found
            diseases = [case.disease for case in active_cases]
            severity = calc_severity(diseases)
            spreadability = calc_spreadability(diseases)
        else: # diseases have NOT been found (still some risk that diseases are present)
            diseases = []
            severity = 0.5
            spreadability = 0.5
            variety_score = 0.5
            location_score = 0.5
        
        variety_score = calc_variety_score(orchard.variety)
        location_score = calc_location_score(orchard.location)
        stocking_score, stocking_rate = calc_stocking_score(orchard)
        last_check_score, time_last_check = calc_last_check_score(orchard)
        season_score, season_info = calc_season_score(orchard)
        sensitivity_score = calc_sensitivity_score(orchard)
        
        risk_score = (
            weightings['severity'] * severity +
            weightings['spreadability'] * spreadability +
            weightings['variety_score'] * variety_score +
            weightings['location_score'] * location_score +
            weightings['stocking_score'] * stocking_score +
            weightings['last_check_score'] * last_check_score +
            weightings['season_score'] * season_score + 
            weightings['sensitivity_score'] * sensitivity_score
        )
        
        data_used = {
            'diseases': diseases,
            'location': orchard.location,
            'variety':orchard.variety,
            'stocking_rate': stocking_rate,
            'season_info': season_info,
            'time_last_check': time_last_check,
            'sensitivity_score': round(sensitivity_score,2),
        }
        
        plan.append({
            'orchard': orchard.orchardName,
            'risk_score': round(risk_score, 2),
            'data_used': data_used,
        })
    
        
    return plan

# ------ FUNCTIONS USED TO GENERATE NORMALISED SCORES FOR EACH PARAMETER -------
def calc_severity(diseases):
    """
    Normalize disease severity to a 0-1 scale.
    """
    
    return max([disease.severity for disease in diseases]) / 10


def calc_spreadability(diseases):
    """
    Normalize disease spreadability to a 0-1 scale.
    """
    
    return max([disease.spreadability for disease in diseases]) / 10


def calc_variety_score(variety):
    """
    Get the variety's susceptibility to the disease, normalized to 0-1.
    """
    return variety.varietySusceptability / 10


def calc_location_score(location):
    """
    Get the location's susceptibility to the disease, normalized to 0-1.
    """

    return location.locationSusceptability / 10


def calc_stocking_score(orchard):
    """
    Estimate tree density as a stocking score, normalized to 0-1. 
    Returns stocking_score and stocking_rate
    """
    stocking_rate = (orchard.noTreesRow * orchard.noTreesColumn) / orchard.area
    
    # an ultra high-density mango plantation has a density of 1000/acre, which will define the maximum value of our stocking rate
    return (min(stocking_rate / 0.37, 1), round(stocking_rate / 0.37, 2))


def calc_last_check_score(orchard):
    """
    Calculate how long since last check, normalized to 0-1 over 30 days.
    Returns last_check_score and days_since_last_check
    """
    last_record = Record.objects.filter(orchard=orchard).order_by('-recordedAt').first()
    
    if not last_record:
        return 1, "No records." # highest risk, no record
    
    days_since_last_check = (date.today() - last_record.recordedAt).days
    
    return (min(days_since_last_check / 30, 1), days_since_last_check) # no check in the last 30 days is considered highest risk


def calc_season_score(orchard):
    """
    Assign a risk score based on the current month/season.
    Higher scores reflect seasons with higher disease or pest pressure.
    
    Northern Hemisphere
    High risk: Nov-Feb, Medium risk: Mar-May, Low risk: Jun-Oct

    Southern Hemisphere
    High risk: May-Aug, Medium risk: Sep-Nov, Low risk: Dec-Apr
    
    Returns
        float: season risk score (0 to 1)
        string: month and hemisphere in this format f"{month_name} ({hemisphere}ern Hemisphere)"
    """
    month = date.today().month
    hemisphere = orchard.location.hemisphere
    
    month_name = calendar.month_name[month]
    
    if hemisphere == 'north':
        if month in [11, 12, 1, 2]:
            risk_score = 1
        elif month in [3, 4, 5]:
            risk_score = 0.5
        else:
            risk_score = 0
    else:
        if month in [5, 6, 7, 8]:
            risk_score = 1
        elif month in [9, 10, 11]:
            risk_score = 0.5
        else:
            risk_score = 0
        
    return risk_score, f"{month_name} ({hemisphere.capitalize()}ern Hemisphere)"
        
def calc_sensitivity_score(orchard):
    """
    Calculate sensitivity as % of orchard checked in recent record.
    Higher sensitivity (more trees checked) reduces risk.
    """
    
    def calculate_sensitivity(N, y, n):
        """
        Calculate sensitivity for detecting infested trees. Based on formula provided by Dr Anne Walters.

        Args:
            N (int): Total number of trees in the orchard.
            y (int): Number of infested trees.
            n (int): Number of trees sampled.

        Returns:
            float: Sensitivity (probability of detecting at least one infested tree).
        """
        
        if y == 0 or n == 0: # no infested trees or no trees sampled
            return 0
        
        if n > N: # not possible to sample more trees than you have
            n = N 
        
        return 1 - (comb(N - y, n) / comb(N,n))
    
    last_record = Record.objects.filter(
        orchard=orchard,
        case__status='active', # __ syntax allows you traverse up by Foreign keys
    ).order_by('-recordedAt').first()
    
    if not last_record: # no records (this should not be needed if database is populated correctly)
        return 0
        
    orchard_size = orchard.noTreesRow * orchard.noTreesColumn
    
    return calculate_sensitivity(orchard_size, last_record.numberOfTreesInfected, last_record.numberOfTreesChecked)