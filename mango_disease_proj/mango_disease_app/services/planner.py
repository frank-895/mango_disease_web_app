from mango_disease_app.models import *
from datetime import date

### ------ THE IDEA BEHIND THIS PLANNER ALGORITHM -------
# This planner defines numerous factors that interplay when deciding how often an orchard needs to be checked
# While the weightings have only been loosely chosen based on evidence or heuristics
# It is very easy to redefine them based on expert advice before the application is formally deployed.

def generate_plan(user):
    """
    Doc-string generated by GPT-4
    
    Generates a disease monitoring plan for all orchards owned by the given user.
    
    This function uses a risk-scoring model that prioritizes worst-case scenarios by:
    - Evaluating all active disease records per orchard
    - Selecting the maximum (most severe) values for key disease-related factors
    - Estimating risk even when no records exist using conservative default scores

    Querying Strategy:
    ------------------
    - Only 'active' disease records are considered (`status='active'`).
    - All diseases found in these records are collected per orchard.
    - For each orchard, the highest severity and spreadability values across these diseases are used.
    - The most severe disease is also used to calculate the highest variety and location susceptibility scores.
    - If no records are present, the function assigns moderate default values (0.5) to reflect unknown but possible risk.
    - Other agronomic and environmental risk factors (tree density, last check date, season) are always computed.

    Parameters:
    -----------
    user : User
        The currently authenticated user whose orchards will be evaluated.

    Risk Factors (All normalized to 0-1):
    -------------------------------------
    - severity : float
        Maximum disease severity across active records.

    - spreadability : float
        Maximum disease spreadability across active records.

    - variety_score : float
        Maximum susceptibility of the orchard's mango variety to any active disease.

    - location_score : float
        Maximum susceptibility of the orchard's location to any active disease.

    - stocking_score : float
        Tree density normalized based on a max of ~1500 trees/acre.

    - last_check_score : float
        Normalized days since the orchard's last disease record (max risk after 30+ days).

    - season_score : float
        Season-based risk depending on the orchard's hemisphere and current month.

    Returns:
    --------
    list of dict:
        A list containing one dictionary per orchard, with:
        - 'orchard': The name of the orchard
        - 'risk_score': The total weighted risk score (rounded to 2 decimal places)

    Notes:
    ------
    - The risk_score is a weighted sum of the factors defined above.
    - This can be used to drive decision-making on inspection frequency (e.g., "Every 3 days").
    - The weightings can and should be adjusted based on expert agronomic advice.
    """
        
    # ----- REDEFINE WEIGHTINGS HERE BASED ON EXPERT EVIDENCE ------
    # should add to 1
    weightings = {
        'severity':0.2,
        'spreadability':0.2,
        'variety_score':0.025,
        'location_score':0.025,
        'stocking_score':0.2,
        'last_check_score':0.05,
        'season_score':0.3,        
    }
    
    orchards = Orchard.objects.filter(user=user)
    plan = []
    data_used = {}
    
    for orchard in orchards:
        # records that are active and associated with the orchard
        active_records = Record.objects.filter(orchardID=orchard, status='active')
        
        if active_records.exists():
            diseases = [record.disease for record in active_records]
            severity = calc_severity(diseases)
            spreadability = calc_spreadability(diseases)
            variety_score = calc_variety_score(orchard.variety, diseases)
            location_score = calc_location_score(orchard.location, diseases)
        else:
            # if there are no records, it is indicative of some risk that the diseases have just not been detected
            severity = 0.5
            spreadability = 0.5
            variety_score = 0.5
            location_score = 0.5
        
        stocking_score, data_used['stocking_rate'] = calc_stocking_score(orchard)
        last_check_score, data_used['time_last_check'] = calc_last_check_score(orchard)
        season_score = calc_season_score(orchard)
        
        risk_score = (
            weightings['severity'] * severity +
            weightings['spreadability'] * spreadability +
            weightings['variety_score'] * variety_score +
            weightings['location_score'] * location_score +
            weightings['stocking_score'] * stocking_score +
            weightings['last_check_score'] * last_check_score +
            weightings['season_score'] * season_score
        )

        data_used['diseases'] = diseases
        data_used['location'] = orchard.location
        data_used['no_trees'] = orchard.noTreesRow * orchard.noTreesColumn
        
        plan.append({
            'orchard': orchard.orchardName,
            'risk_score': round(risk_score, 2),
            'data_used': data_used,
        })
        
    return plan

# ------ FUNCTIONS USED TO GENERATE NORMALISED SCORES FOR EACH PARAMETER -------
def calc_severity(diseases):
    """
    Normalize disease severity to a 0-1 scale.
    """
    
    return max([disease.severity for disease in diseases]) / 10


def calc_spreadability(diseases):
    """
    Normalize disease spreadability to a 0-1 scale.
    """
    
    return max([disease.spreadability for disease in diseases]) / 10


def calc_variety_score(variety, diseases):
    """
    Get the variety's susceptibility to the disease, normalized to 0-1.
    """
    suscpetibilities = [
        vd.varietySusceptability
        for disease in diseases
        if (vd := VarietyDisease.objects.filter(variety=variety, disease=disease).first()) # := is the walrus operator for in-line assignment
    ]
    
    return max(suscpetibilities, default=0) / 10


def calc_location_score(location, diseases):
    """
    Get the location's susceptibility to the disease, normalized to 0-1.
    """
    suscpetibilities = [
        vd.locationSusceptability
        for disease in diseases
        if (vd := LocationDisease.objects.filter(location=location, disease=disease).first()) # := is the walrus operator for in-line assignment
    ]
        
    return max(suscpetibilities, default=0) / 10


def calc_stocking_score(orchard):
    """
    Estimate tree density as a stocking score, normalized to 0-1. 
    Returns stocking_score and stocking_rate
    """
    stocking_rate = (orchard.noTreesRow * orchard.noTreesColumn) / orchard.area
    
    # an ultra high-density mango plantation has a density of 1000/acre, which will define the maximum value of our stocking rate
    return (min(stocking_rate / 0.37, 1), stocking_rate)


def calc_last_check_score(orchard):
    """
    Calculate how long since last check, normalized to 0-1 over 30 days.
    Returns last_check_score and days_since_last_check
    """
    today = date.today()
    last_check_date = Record.objects.filter(orchardID=orchard).order_by('-recordedAt').first()
    
    if not last_check_date:
        return 1 # highest risk, no record
    
    days_since_last_check = (today - last_check_date.recordedAt).days
    
    return (min(days_since_last_check / 30, 1), days_since_last_check) # no check in the last 30 days is considered highest risk


def calc_season_score(orchard):
    """
    Assign a risk score based on the current month/season.
    Higher scores reflect seasons with higher disease or pest pressure.
    
    Northern Hemisphere
    High risk: Nov-Feb, Medium risk: Mar-May, Low risk: Jun-Oct

    Southern Hemisphere
    High risk: May-Aug, Medium risk: Sep-Nov, Low risk: Dec-Apr
    """
    month = date.today().month
    hemisphere = orchard.location.hemisphere
    
    if hemisphere == 'north':
        if month in [11, 12, 1, 2]:
            return 1
        elif month in [3, 4, 5]:
            return 0.5
        else:
            return 0
    else:
        if month in [5, 6, 7, 8]:
            return 1
        elif month in [9, 10, 11]:
            return 0.5
        else:
            return 0